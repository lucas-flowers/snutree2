
from collections import defaultdict
from dataclasses import dataclass
from itertools import count

from ..member import Member, ExtendedMember
from .model import Entity, Relationship, Cohort, FamilyTree

from ...utilities import get

def create(members, config=None):
    factory = TreeFactory(config or {})
    return factory.create(members)

class IdentifierFactory(count):
    # TODO More robustly prevent autogenerated identifiers from clashing with user identifiers
    def __new__(cls):
        return super().__new__(cls, start=1, step=1)
    def __next__(self):
        return ':' + str(super().__next__())

@dataclass
class TreeFactory:

    config: dict

    def entities(self, extended_member):
        return list(filter(bool, [
            self.entity(extended_member),
            self.parent_entity(extended_member),
        ]))

    def entity(self, extended_member):
        return Entity(
            id=extended_member.id,
            classes=extended_member.classes,
            data=extended_member.data,
        )

    def parent_entity(self, extended_member):
        return None if not extended_member.has_unknown_parent else Entity(
            id=extended_member.parent_id,
            classes=['root', 'unknown'],
        )

    def relationship(self, extended_member):
        return None if extended_member.parent_id is None else Relationship(
            from_id=extended_member.parent_id,
            to_id=extended_member.id,
            # TODO Figure out the classes exactly and whether to include member.classes
            classes=[
                'root',
                'unknown' if extended_member.has_unknown_parent else 'tree',
                *extended_member.classes, # TODO Include this?
            ],
            data=extended_member.data, # TODO ?
        )

    def extended_member(self, member, identifiers):
        has_unknown_parent = all([
            member.parent_id is None,
            not member.id in get(self.config, 'roots'),
        ])
        return ExtendedMember(
            id=member.id if member.id is not None else next(identifiers),
            parent_id=member.parent_id if not has_unknown_parent else next(identifiers),
            rank=member.rank,
            has_unknown_parent=has_unknown_parent, # TODO
            classes=member.classes,
            data=member.data,
        )

    def extended_members(self, members):
        identifiers = IdentifierFactory()
        return [
            self.extended_member(member, identifiers)
            for member in members
        ]

    def cohorts(self, extended_members):

        rank_to_ids = defaultdict(list)
        min_rank, max_rank = None, None
        for extended_member in extended_members:
            if min_rank is None or extended_member.rank < min_rank:
                min_rank = extended_member.rank
            if max_rank is None or extended_member.rank > max_rank:
                max_rank = extended_member.rank
            rank_to_ids[extended_member.rank].append(extended_member.id)
            if extended_member.has_unknown_parent:
                rank_to_ids[extended_member.rank - 1].append(extended_member.parent_id)

        if min_rank is None and max_rank is None:
            all_ranks = []
        else:
            all_ranks = (min_rank + i for i in range(max_rank - min_rank + 1))

        return [
            Cohort(
                rank=rank,
                ids=rank_to_ids[rank],
                classes=['root', 'rank'],
                data={'rank': rank},
            )
            for rank in all_ranks
        ]

    def create(self, members):
        extended_members = self.extended_members(members)
        return self.family_tree(extended_members)

    def family_tree(self, extended_members):
        return FamilyTree(
            entities=[
                entity
                for extended_member in extended_members
                for entity in self.entities(extended_member)
            ],
            relationships=[
                relationship
                for relationship in map(self.relationship, extended_members)
                if relationship is not None
            ],
            cohorts=self.cohorts(extended_members),
            classes=['root'], # TODO ???
            data={}, # TODO ???
        )


